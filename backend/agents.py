import os, sqlite3, json, re, psutil, time, sys, uuid, logging
from datetime import datetime
from enum import Enum
from typing import List, Dict, Any, Optional
from dotenv import load_dotenv

from ollama_client import generate, get_last_stats
from telemetry import Telemetry  # <-- new import for transaction logging

# ================= Logging =================
log_dir = "logs"
if not os.path.exists(log_dir):
    os.makedirs(log_dir)

file_handler = logging.FileHandler(
    f'{log_dir}/agents_{datetime.now().strftime("%Y%m%d")}.log',
    encoding="utf-8"  # âœ… ensure UTF-8 in file
)
stream_handler = logging.StreamHandler()  # console (keep ASCII-safe content)

logging.basicConfig(
    level=logging.INFO,
    format='%(asctime)s - %(name)s - %(levelname)s - %(message)s',
    handlers=[file_handler, stream_handler]
)
logger = logging.getLogger(__name__)

# ================= Env Config =================
load_dotenv()
SQLITE_PATH = os.getenv("SQLITE_PATH", "./rag_memory.db")

MODEL = {
    "rag":      os.getenv("LLM_RAG",      "mistral:7b-instruct"),
    "code":     os.getenv("LLM_CODE",     "Qwen2.5-Coder:latest"),
    "sql":      os.getenv("LLM_SQL",      "sqlcoder:latest"),
    "fallback": os.getenv("LLM_FALLBACK", "llama3:latest"),
}

process = psutil.Process()
logger.info("=== System Information ===")
logger.info(f"Python Version: {sys.version}")
logger.info(f"CPU Count: {psutil.cpu_count()}")
logger.info(f"Available Memory: {psutil.virtual_memory().available / (1024*1024*1024):.2f} GB")
logger.info(f"PID: {process.pid}")
logger.info(f"Models: {MODEL}")
logger.info("========================")

telemetry = Telemetry()  # global telemetry DB handler

# ================= Helper Decorator =================
def log_execution_time(func):
    def wrapper(*args, **kwargs):
        req_id = str(uuid.uuid4())[:8]
        start = time.time()
        start_mem = process.memory_info().rss / (1024 * 1024)
        logger.info(f"[{req_id}] Start {func.__name__}")
        try:
            result = func(*args, **kwargs)
            dur = time.time() - start
            mem = process.memory_info().rss / (1024 * 1024) - start_mem
            logger.info(f"[{req_id}] Done {func.__name__} in {dur:.2f}s  - {mem:.2f}MB")
            return result
        except Exception as e:
            logger.error(f"[{req_id}] Fail {func.__name__}: {e}", exc_info=True)
            raise
    return wrapper


def _ensure_fenced_code(text: str, default_lang: str = "python") -> str:
    if "```" in (text or ""):
        return text
    clean = (text or "").strip() or "# (no content returned)"
    return f"```{default_lang}\n{clean}\n```"


# ================= Memory =================
class Memory:
    def __init__(self, path: str = SQLITE_PATH):
        logger.info(f"Memory DB path: {path}")
        self.conn = sqlite3.connect(path, check_same_thread=False)
        self._ensure()

    def _ensure(self):
        cur = self.conn.cursor()
        cur.execute("""CREATE TABLE IF NOT EXISTS memories(
            session_id TEXT, user TEXT, assistant TEXT, citations TEXT,
            ts DATETIME DEFAULT CURRENT_TIMESTAMP
        )""")
        self.conn.commit()

    @log_execution_time
    def save(self, session_id: str, user: str, assistant: str, citations: List[Dict[str, Any]]):
        cur = self.conn.cursor()
        cur.execute("INSERT INTO memories(session_id,user,assistant,citations) VALUES(?,?,?,?)",
                    (session_id, user, assistant, json.dumps(citations)))
        self.conn.commit()


# ================= Routing =================
class Route(Enum):
    RAG = "RAG"
    CODE = "CODE"
    SQL  = "SQL"

class Policy:
    @staticmethod
    @log_execution_time
    def decide(query: str) -> Route:
        q = (query or "").lower()
        if any(k in q for k in ["select ", "sql ", "schema", "table", "join ", "group by", "where "]):
            return Route.SQL
        if any(k in q for k in ["code", "function", "class", "bug", "refactor", "python", "typescript", " js ", "javascript"]):
            return Route.CODE
        return Route.RAG


# ================= Answer Functions =================
@log_execution_time
def answer_rag(query: str, context: str, session_id: str | None = None) -> str:
    logger.info(f"Processing RAG query: {query} (session={session_id})")
    logger.debug(f"Context length: {len(context)} characters")
    try:
        prompt = f"""You are a helpful assistant. Use CONTEXT to answer QUESTION concisely.
If the answer is not in the context, You can feel free to use the available models, but just mention  that you asked message is not in the provided context or injested content, it is generated by the model, you can mention the model name too.

CONTEXT:
{context}

QUESTION: {query}

Answer in bullet points. Add short citations like [doc-id] when you directly use a snippet.
"""
        response = generate("llama3", prompt)
        logger.info("RAG response generated successfully")
        logger.debug(f"Response: {response[:100]}...")
        return response
    except Exception as e:
        logger.error(f"RAG answer generation failed: {str(e)}", exc_info=True)
        raise

@log_execution_time
def answer_code(query: str, context: str, session_id: str | None = None) -> str:
    logger.info(f"Processing CODE query: {query} (session={session_id})")
    logger.debug(f"Context length: {len(context)} characters")
    try:
        prompt = f"""You are a senior engineer. Based on REQUEST and any useful CONTEXT,
produce a brief plan and working code. If assumptions are needed, list them.

CONTEXT:
{context}

REQUEST:
{query}

Return:
- Plan (3-5 bullets)
- Code block(s)
- Notes on how to run
"""
        response = generate("llama3", prompt)
        logger.info("Code response generated successfully")
        logger.debug(f"Response: {response[:100]}...")
        return response
    except Exception as e:
        logger.error(f"Code answer generation failed: {str(e)}", exc_info=True)
        raise

@log_execution_time
def answer_sql(query: str, session_id: str | None = None) -> str:
    logger.info(f"Processing SQL query: {query} (session={session_id})")
    try:
        schema_hint = """
-- Tables available:
-- memories(session_id TEXT, user TEXT, assistant TEXT, citations TEXT, ts DATETIME)
-- docs(id TEXT PRIMARY KEY, text TEXT, source TEXT)
"""
        llm = generate("sqlcoder", f"""You are SQLCoder. Produce a single SQLite query in a fenced ```sql``` block
that satisfies the USER REQUEST. Use only existing columns. Then add a 1-2 line explanation.

DB SCHEMA:
{schema_hint}

USER REQUEST:
{query}
""")
        logger.info("SQL query generated by LLM")
        logger.debug(f"LLM response: {llm[:100]}...")

        sql = _extract_sql(llm)
        if not sql:
            logger.warning("No SQL query found in LLM response")
            return llm

        try:
            conn = sqlite3.connect(SQLITE_PATH, check_same_thread=False)
            cur = conn.cursor()
            cur.execute(sql)
            rows = cur.fetchall()
            cols = [d[0] for d in cur.description] if cur.description else []
            payload = {"columns": cols, "rows": rows}
            logger.info(f"SQL execution successful, returned {len(rows)} rows")
            return llm + "\n\n-- Execution Result --\n" + json.dumps(payload, indent=2, default=str)
        except Exception as e:
            logger.error(f"SQL execution failed: {str(e)}", exc_info=True)
            return llm + f"\n\n[Execution Error] {e}"
    except Exception as e:
        logger.error(f"SQL answer generation failed: {str(e)}", exc_info=True)
        raise

def _extract_sql(text: str) -> Optional[str]:
    m = re.search(r"sql\s*([\s\S]*?)", text or "", re.IGNORECASE)
    return m.group(1).strip().rstrip(";") if m else None
